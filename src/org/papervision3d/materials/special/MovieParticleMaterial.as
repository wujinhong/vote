package org.papervision3d.materials.special{	import flash.display.DisplayObject;	import flash.utils.Dictionary;		import org.papervision3d.core.geom.renderables.Particle;	import org.papervision3d.core.render.data.RenderSessionData;	import org.papervision3d.core.render.material.IUpdateBeforeMaterial;		/**	 * @author Seb Lee-Delisle	 * 	 * version 0.1 of MovieAssetParticleMaterial that uses a reference to a	 * library symbol to create a particle.	 * 	 */	public class MovieParticleMaterial extends BitmapParticleMaterial implements IUpdateBeforeMaterial //, IUpdateAfterMaterial	{					// TODO create object to store bitmap and spriterectdata (and USECOUNT!!!) for each type of bitmap		public static var bitmapLibrary : Dictionary = new Dictionary(true); // add usecount to ParticleBitmap				//private var _animated : Boolean; // animated movieclip - FOR FUTURE USE! NOT IMPLEMENTED YET :-) 				//public var createUnique : Boolean = false; 				/**		* The MovieClip that is used as a texture.		*/		public var movie :DisplayObject;		/**		* A Boolean value that determines whether the MovieClip is transparent. The default value is true, which, 		* although slower, is usually what you need for particles.		*/		//public var movieTransparent :Boolean;				//protected var bitmapDrawMatrix : Matrix; 		public var animated : Boolean; 		public var forceMipMap : Boolean;		public var actualSize : Boolean = false; 		public var scale : Number = 1; 		//public var maxSize : int = 1000; 		//public var allowAutoResize:Boolean = true; // FOR FUTURE USE! 						// __________________________________________________ NEW				/**		 * A Particle material that is made from a single DisplayObject (Sprite, MovieClip, etc) or a		 * Class that extends a DisplayObject (ie a library symbol)		 * 		 * v0.1 - TODO implement reusable assets in the same way as MovieAssetMaterial		 * 		 * @param linkageID		The Library symbol to make the material out of.		 * @param transparent	[optional] - whether the image is transparent or not		 * @param animated		[optional] NOT IMPLEMENTED YET! Please do not use!		 * @param createUnique	If true, we'll make a bitmap especially for use with this instance of the material, otherwise we'll use a cached version (if there is one)		 * 		 */		public function MovieParticleMaterial(displayobject: DisplayObject, transparent:Boolean = true, animated : Boolean = false, forceMipMap : Boolean = false)		{						if(displayobject) movie = displayobject;			this.animated = animated; 			this.forceMipMap = forceMipMap; 						updateParticleBitmap();						super(particleBitmap);					}								public function updateParticleBitmap(scale : Number = 1, posX : Number=0, posY : Number=0) : void		{			if(particleBitmap)								particleBitmap.create(movie, scale, forceMipMap, posX, posY);			else				particleBitmap = new ParticleBitmap(movie, scale, forceMipMap, posX, posY);					}				override public function updateRenderRect(particle: Particle) : void		{										if(actualSize)			{				updateParticleBitmap(particle.renderScale*particle.size, particle.vertex3D.vertex3DInstance.x, particle.vertex3D.vertex3DInstance.y); 							} 			else if(animated)			{				updateParticleBitmap(scale); 											}						super.updateRenderRect(particle); 						if(actualSize) 			{				//particle.drawMatrix.translate(-(particle.vertex3D.vertex3DInstance.x%1), -(particle.vertex3D.vertex3DInstance.y%1)); 					}		}		/*		override public function drawParticle(particle:Particle, graphics:Graphics, renderSessionData:RenderSessionData):void		{			var cullingrect:Rectangle = renderSessionData.viewPort.cullingRectangle;						FastRectangleTools.intersection(cullingrect, particle.renderRect, renderRect);														graphics.beginBitmapFill(bitmap, bitmapFillMatrix, false, smooth);			graphics.drawRect(renderRect.x, renderRect.y, renderRect.width, renderRect.height);			graphics.endFill();						graphics.lineStyle();						renderSessionData.renderStatistics.particles++;					//	trace("drawParticle"); 		}				override public function updateRenderRect(particle : Particle) :void		{						//var osx:Number;			//var osy:Number;								bitmapFillMatrix.identity();						if(animated) spriteRect = movie.getBounds(movie); 						var newscale : Number = particle.renderScale*particle.size;						// renderrect is the rectangle on screen that we're using to render into			var renderrect:Rectangle = particle.renderRect; 									if(!actualSize) 			{				bitmapFillMatrix.scale(newscale, newscale);								renderrect.width = newscale*spriteRect.width;				renderrect.height = newscale*spriteRect.height;								//The renderrect's offset == the 3D point plus the scaled offset of the asset				renderrect.x = particle.vertex3D.vertex3DInstance.x+(spriteRect.left*newscale);				renderrect.y = particle.vertex3D.vertex3DInstance.y+(spriteRect.top*newscale);								bitmapFillMatrix.translate(renderrect.x, renderrect.y); 							}			else 			{				// scale the movie asset to fit its 3D counterpart				movie.scaleX = movie.scaleY = newscale;								renderrect.width = movie.width;				renderrect.height = movie.height;																//The renderrect's offset == the 3D point plus the scaled offset of the asset				renderrect.x = particle.vertex3D.vertex3DInstance.x+(spriteRect.left*newscale);				renderrect.y = particle.vertex3D.vertex3DInstance.y+(spriteRect.top*newscale);								bitmapFillMatrix.translate(renderrect.x, renderrect.y); 															}										if(animated)			{				//trace("updateBeforeRender", this.movie.name); 				drawBitmap(); 			}								//	trace("updateRenderRect", renderrect.left, renderrect.top, renderrect.x, renderrect.y); 					}				*/		/*		override public function destroy() :void		{			super.destroy(); 			// TODO Implement bitmap count for dictionary bitmaps and smart disposal			if(createUnique) bitmap.dispose(); 			else			{				useCount[movie]--; 				if(useCount[movie]==0)xp				{					bitmapLibrary[movie].dispose(); 					bitmapLibrary[movie] = null; 					spriteRectLibrary[movie] = null; 								}											}					}		*/		public function updateBeforeRender(renderSessionData:RenderSessionData):void		{								}								/*		public function drawBitmap() : void		{						spriteRect = movie.getBounds(movie); 						//spriteRect.left *= movie.scaleX; 			//spriteRect.top *= movie.scaleY; 			//spriteRect.width *= movie.scaleX; 			//spriteRect.height *= movie.scaleY; 			var newwidth  : Number = spriteRect.width; 			var newheight : Number = spriteRect.height; 						if(actualSize)			{				newwidth*=movie.scaleX; 				newheight*=movie.scaleY; 							}			// i suspect the following is more optimised than newwidth = Math.max(newwidth, 1); 			if(newwidth==0) newwidth = 1; 			if(newheight==0) newheight = 1; 						var newscale : Number = 1; 						if(newwidth>maxSize) 			{				//newscale = (maxSize/newwidth);				//newheight *= newscale;				newwidth = maxSize;  			}				if(newheight>maxSize) 			{				//newscale = (maxSize/newheight);				//newwidth *= newscale; 				newheight = maxSize;  			}									//if we don't have a bitmap, or we need a new, bigger bitmap, then make one!			if((bitmap===null) || bitmap.width<newwidth || bitmap.height<newheight)			{				//trace("new bitmap", (bitmap===null))				if(!(bitmap===null)) 				{					//trace("\t", bitmap.width, spriteRect.width, bitmap.height, spriteRect.height); 					bitmap.dispose(); 								}				bitmap = new BitmapData(newwidth, newheight, movieTransparent, 0x00000000);							if(!createUnique)				{					bitmapLibrary[movie] = bitmap;					spriteRectLibrary[movie] = spriteRect; 					useCount[movie] = 1; 				} 			}									bitmapDrawMatrix.identity(); 			bitmapDrawMatrix.tx = -spriteRect.left;			bitmapDrawMatrix.ty = -spriteRect.top;						if(actualSize)			{				bitmapDrawMatrix.scale(movie.scaleX, movie.scaleY);								var osx : Number = bitmapFillMatrix.tx - Math.floor(bitmapFillMatrix.tx);				var osy : Number = bitmapFillMatrix.ty - Math.floor(bitmapFillMatrix.ty); 								bitmapFillMatrix.translate(-osx,-osy); 			//	bitmapFillMatrix.scale(1/newscale,1/newscale); 				bitmapDrawMatrix.translate(osx, osy); 											}						bitmap.fillRect(bitmap.rect, 0x00000000); 			bitmap.draw(movie, bitmapDrawMatrix); 								}				public function updateAfterRender(renderSessionData:RenderSessionData):void		{					}		*/			}}